# iot-c-programming-2025
IoT 개발자 심화 프로그래밍 언어 리포지토리

## 1일차
- 프로그래밍 언어 종류
    - 저급언어: 컴퓨터가 직접 이해하고 실행하는 언어. ex) 기계어, 어셈블리어
    - 고급언어: 사용자가 이해하기 쉽게 만들어진 언어. ex) C/C++, Python, JAVA
    - 절차지향 언어 : 함수 중요
    - 객체지향 언어 : 클래스 중요

- Visual Studio c언어 파일 만들기: 소스파일 -> 추가 -> 새파일 -> 파일명 설정

- c언어 기본셋팅
    ```c
        #include <stdio.h>

        int main() 
        {
            return 0;
        }
    ```
    - #include <stdio.h> : stdio.h라는 헤더파일(.h)을 포함하라는 의미.
    - 메인 함수는 운영체제가 호출함
    - void main() : 반환 값 X
    - int main(void) : 입력 값 X

- bit, byte, nybble, 진수, 보수
    - bit : 0 또는 1인 값
    - byte : 8bit
    - nybble : 4bit
    - 진수: 숫자를 표현하는 방식,
        - 2진수: 0 또는 1
        - 10진수 : 0 ~ 9, %d
        - 8진수 : 0 ~ 7, %o 
        - 16진수 : 0 ~ 9, A(10) ~ F(15), %x
    - 뺄셈 연산, 보수 사용
        - 1의 보수: 0은 1, 1은 0으로 비트 반전
        - 2의 보수: 1의 보수 결과에 1을 더함.

- 자료형
    - int : 정수형(%d)
    - float : 실수형(%f)
    - double : 실수형(%lf)
    - char : 문자형(%c) | 문자열(%s), 문자는 출력함수 printf()에서 따옴표(''), 문자열은 쌍따옴표 ("")

- ROM과 RAM
    - ROM : 읽기 전용 메모리(데이터 수정 불가능), 비휘발성 메모리로 전원이 꺼져도 저장된 데이터는 사라지지 않음. 느림
    - RAM : 읽기/쓰기 메모리(데이터 수정 가능), 휘발성 메모리로 전원이 꺼지면 저장된 모든 데이터가 사라짐. 빠름, 변수는 RAM에 저장.

- 변수
    - 값을 저장하는 메모리 공간, 값 수정가능
    - 변수 선언 및 초기화: 자료형 변수이름(lvalue) = 값(rvalue, literal);
    - 전역변수 : 프로그램 전체에서 접근가능
    - 지역변수 : 특정함수 내에서만 사용가능
    - signed : 부호 있는 값, 양수와 음수 모두 저장 : -128 ~ 127
    - unsigned : 부호 없는 값, 양수만 저장 : 0 ~ 255
    - signed, unsigned : int, char, short, long 등의 정수형 자료형에 적용할 수 있다.

- 상수
    - 변하지 않는 고정된 값
    - #define, const 키워드 사용 : const 자료형 변수이름 = 값;

- 배열
    - 같은 데이터 타입을 가지는 연속된 메모리 공간
    - 배열은 배열의 시작주소를 나타냄 -> 주소연산자 필요X (변수는 주소연산자 사용)
    - 맨 마지막 배열에는 배열의 끝을 의미하는 **null**이 입력됨

- printf(); : 출력함수
- scanf() : 입력함수
    - 열의 크기를 자동적으로 알지 못하기 때문에 **sizeof()** 함수 사용


## 2일차
- 연산자 종류
    - 산술연산자 : +, -, *, /, %
    - 비교연산자 : ==, !=, <, >, <=, >=
    - 논리연산자 : &&, ||, !
    - 비트연산자 : &, |, ^, ~, <<, >>
    - 대입연산자 : =, +=, -=, *=, /=, %=
    - 증감연산자 : ++, --
    - 삼항연산자 : (조건 ? 참 : 거짓)
    - 연산자 우선순위 : 산술 -> 비교 -> 비트 -> 논리 -> 대입

- 조건문
    - if, if-else, if-else if-else : if(조건식) {...}
    - switch-case : switch(변수){case 값1:... case 값2:... default:...}
        - break 없으면 끝까지 실행, break있으면 switch문 종료
- 반복문
    - for (초기값; 조건식; 증감식;){...}
    - while (조건식) {...} : break(반복문 종료), continue(다음 반복 진행)

- 사용자 정의 함수
    - 입력과 출력이 없는 함수: 함수 안에서 결과를 나타냄.
        - void 함수이름(){...}
    - 입력만 있는 함수: 실인수를 입력받음.
        - void 함수이름(자료형 매개변수1, ...){...}
    - 입력과 출력이 있는 함수: 실인수를 입력받고, return으로 값을 반환함.
        - 자료형 함수이름(자료형 매개변수1, ...){... return 리턴 값}
        - 계산기 만들기 실습 파일[C](./day02/func4.c)


## 3일차
- 배열
    - 선언 및 초기화 방법: 자료형 배열이름[배열크기] = {...} (배열크기 생략가능)
    - 장점: 순회, 탐색 좋음, 단점: 수정이 어려움 -> 인덱스 사용(값에 접근하기)
    - 문자형 배열의 경우 문자형 배열의 끝을 알리는 null이 저장될 수 있게 (입력할 값 갯수 + 1)을 배열 크기로 지정
- 포인터
    - 메모리 주소를 저장할 수 있는 공간
    - 선언 방법: 자료형* 포인터변수이름; 
        - (이 때 *는 포인터 변수임을 뜻하는 표시일 뿐 아무 의미 없음.)
    - int* p 일 경우
        - 포인터 변수에 저장된 값을 확인하고 싶을 때: p
        - 포인터 변수가 가리키는 곳의 값을 확인할 때: *p (이 때 *는 간접참조연산자)
    - 포인터를 이용한 swap함수 생성 [C](./day03/pointer4.c)
    - 포인터 배열: 인덱스[] 표현 -> *(포인터변수 + 인덱스)
        - [C](./day03/pointer5.c)
        - [C](./day03/pointer6.c)
    - 포인터 상수: const
        - **const** int* 포인터변수 = &변수 : 데이터 상수, 포인터 변수를 통한 데이터의 값 변경을 불허함
        - int* **const** 포인터변수 = &변수 : 포인터 상수, 포인터 변수가 가리키는 주소의 값 변경을 불허함
- 문자 전용 함수
    - 문자 하나를 입력받고 출력하기에 번거로움: getchar, putchar 사용
    - getchar() : 한 문자를 읽어오는 함수 (입력)
    - putchar() : 한 문자를 출력하는 함수 (출력)
        - 줄바꿈이 안 되는 단점이 있음 따로 putchar('\n') 추가


## 4일차

